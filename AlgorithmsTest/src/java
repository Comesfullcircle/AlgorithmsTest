객체 지향 프로그래밍, 클래스, 메소드, 인터페이스

객체 지향 프로그래밍

상태와 행위로 이루어진 객체들 간의 상호작용을 통해 프로그램을 설계 및 개발하는 프로그래밍 패러다임

객체(Object): 현실에 존재하는 대상, 주변에 존재하는 모든 사람, 사물, 동물, 물건 모두
지향(Oriented): 목표로 하는, 기반으로 하는
프로그래밍(Programming): 컴퓨터 프로그램을 작성하는 행위
=> 현실에 존재하는 모든 대상을 기반으로 컴퓨터 프로그램을 작성하는 행위

객체지향 프로그래밍 장점
코드 재사용 용이

모듈화된 객체, 상속을 통해 코드의 재사용성을 높일 수 있음
생산성 향상
독립적인 객체를 사용함으로써 개발의 생산성을 향상시킬 수 있음
자연적인 모델링 가능
현실에서 사용하는 개념을 기반으로 모델링이 되기 때문에 생각한대로 자연스럽게 모델링 가능
유지보수 용이
수정 및 추가 시에 캡슐화 등으로 코드 수정이 적기 때문에 유지보수가 용이함
객체지향 프로그래밍 단점
실행속도가 느림

절차지향 언어보다 상대적으로 실행속도가 느림
프로그램 용량이 커짐
객체 단위로 프로그램을 개발하다보면 프로그램 용량이 커질 수 있음
설계에 많은 시간이 필요함
클래스, 객체, 상속 등을 고려한 프로그래밍을 하려면 설계에 많은 시간을 투자해야 함
객체지향 프로그래밍의 특징
캡슐화

서로 연관있는 속성과 기능을 하나의 클래스로 만들어 분리하는 것
관련이 없는 외부에서는 해당 클래스로 제한적인 접근이 가능
상속
부모 클래스 (물려주는)의 속성과 기능을 자식 클래스 (물려받는)가 가지게 되는 것
A 클래스의 속성과 기능을 B 클래스에서도 사용할 수 있음
예: 라면 이라는 클래스가 있고, 이 클래스를 상속받는 국물 라면, 비빔 라면, 짜장 라면 클래스를 만들 수 있고, 라면 클래스의 기본 속성으로 조리 시간이라는 속성을 만들었다면, 자식 클래스에서도 동일하게 조리 시간이라는 속성을 사용할 수 있음
추상화

각 클래스들의 공통적인 속성과 기능을 정의하여 코드의 중복을 줄이고, 클래스간 관계를 효과적으로 설정하는 것
추상 클래스와 인터페이스를 활용할 수 있음
다형성
두 개 이상의 메소드가 동일한 이름으로 구성될 수 있지만 수행되는 행위는 다를 수 있음 (Overriding, Overloading)
객체지향 프로그래밍 설계 5대 원칙(SOLID)
유지보수성이 높고 확장성과 유연성이 높은 프로그램을 개발하기 위해 활용되는 설계 5대 원칙

Single Responsibility Principle (SRP) 단일 책임 원칙
Open-Closed Principle (OCP) 개방 - 폐쇠 원칙
Liskov Subsititution Principle (LSP) 리스코프 치환 원칙
Interface Segregation Principle (ISP) 인터페이스 분리 원칙
Dependency Inversion Principle (DIP) 의존관계 역전 원칙

클래스 = 형태, 틀, 블루 프린트

class Car { //현재 Car 클래스는 껍데기만 존재

}  

Car hyundaiCar = new Car() //new 는 객체를 생성할 때 사용하는 키워드
Car kisCar = new Car() //hyundaiCar , kisCar등 Car의 객체가 생성됨
...
클래스의 구성 요소
클래스는 객체 변수와 메소드로 구성되어 있음
객체 변수는 속성, 멤버 변수라고 하며 해당 클래스를 표현하기 위한 상태, 값을 가지고 있음
메소드는 클래스에 대한 행위를 표현하기 위함

클래스의 객체 변수와 메소드

class Car {
  private String name;
  
  public String getName() {return name;}
  public void setName(String name) {this.name = name;}

}
name이라는 객체 변수 - Car 의 이름을 표현

getName()과 setName()이라는 메소드

getName() : 이름에 접근하기 위한 메소드
setName() : 이름을 변경하기 위한 메소드
객체 변수와 메소드

class Car{
  private String name;  //Car 클래스에는 name이라는 private변수와 
  public String description; //description이라는 public 변수가 존재
  
  //public 변수의 경우, 도트 연산자(.)으로 객체변수에 접근할 수 있음
 // Car 객체를 생성하기 위해서는 생성자에 name을 입력해야 함
Car(String name) {
     this.name = name; 
  }
 
  
  public String getName() {return name;}
  public void setName(String name) {this.name = name;}
}

Car hyundaiCar = new Car("hyundai");
System.out.println(hyundaiCar.dscription); //null

//name에 접근하기 위해서는 getName()이라는 메소드를 활용해야 함
System.out.println(hyundaiCar.getName()); //"hyundai"

//name의 값을 변경하기 위해서는 setName() 메소드를 활용해야 함
hyundaiCar.setName("kia");
독립적인 객체

class Car{
  private String name;
  public String description;
  
  Car(String name){
    this.name = name;
  }
  
  public String getName() {return name;}
  public void setName(String name) {this.name = name;}
}

//동일한 Car 클래스라도 다른 객체 (hyundai 와 kia)
// 이기 때문에 getName()으로 이름을 조회했을 때 다른 값이 나옴
Car hyundaiCar = new Car("hyundai");
Car kiaCar = new Car("kia");
hyundaiCar.getName() // hyundai
kiaCar.getName() // kia
this 이해하기
this 는 클래스 자기 자신을 의미함

class User {
  private String name;

  User(String name){
    this.name = name;
  }
}
생성자(constructor)
하나의 객체가 생성될 때 객체 변수에 값을 설정할 수 있도록 함

class Student {
  private String name;
  
  Student(String name){
    this.name = name;
  }
  
  String getName() {return this.name;}
  
  Student denny = new Student("danny.kim");
  denny.getName(); //denny.kim
}
클래스명과 메소드명이 동일함
리턴 타입을 정의하지 않고 void도 따로 적지 않음
메소드란?
메소드 = method = 클래스 내 함수
입력 값을 함수에 넣고 어떤 출력 값을 기대

메소드를 사용하는 이유

반복적인 구문을 메소드로 묶어 어떤 입력 값이 주어졌을 때, 어떤 출력값을 반환
int a = 10;
int b = 20;
int c = 30;
int d = 40;
int e = 50;
int f = 60;

int resultA = a + b;
int resultB = c + d;
int resultC = e + f;
=>

int sum(int a, int b){
  return a + b;
}

int a = 10;
int b = 20;
int c = 30;
int d = 40;
int e = 50;
int f = 60;

int resultA = sum(a, b);
int resultB = sum(c, d);
int resultC = sum(e, f);
메소드의 구조
sum 이름의 메소드로 2개의 파라미터 (정수 a와 b)를 받아 더하기를 한 정수 integer 값을 반환

int sum(int a, int b){
  return a + b;
}

리턴 자료형 메소드명(입력자료형1 매개변수1, 입력자료형2 매개변수2,...){
  ...
  return 리턴값;
}
메소드의 구조
1. 입력과 출력이 모두 존재하는 메소드

int sum(int a, inr b) { return a + b; }
입력과 출력이 모두 존재하지 않는 메소드
void print() { System.out.println("hello world!");}
입력만 존재하는 메소드
void printName(int name){ System.out.println("my name is" + name);}
출력만 존재하는 메소드
String getName(){ return "danny";}
매개 변수와 인수
매개 변수 = parameters = 매소드에 전달된 입력값을 저장하는 변수
인수 = arguments = 메소드를 호출할 때 전달하는 입력값

int sum(int a, int b){
  //a와 b는 매개 변수(parameters) 
  return a + b;
}

sum(1,2) //1과 2는 인수(arguments)
return의 활용법
메소드의 결과값을 반환하기 위해 사용하기도 하지만 특정 메소드를 바로 종료하고 싶을 때 사용하기도 함

void printName(String name){
  if ("danny".equals(name)){
     return;
  }
  System.out.println("my name is" + name);
}

//danny라는 이름이 아닐 때만 print 를 함
}
equals()의 활용법

void printName(String name){
  if("danny".equals(name)){
    return;
  }
   System.out.println("my name is" + name);
}

//null pointer exception (NPE) 오류가 발생할 수 있음 
void printName(String name){
  if (name.equals("danny")){
    return;
  }
  System.out.println("my name is" + name);
}
메소드와 변수의 scope

void variableTest(int a) {
  a = a + 1;
}

void main(){
  int a = 1;
  variableTest(a);
  System.out.println(a); //1
}
main()에서 사용하는 변수 a 와 variableTest() 에서 사용하는 변수 a는 서로 다름(서로 독립적)

인터페이스의 구조

interface Vehicle{
  void drive();
  void addFuel();
}
class 키워드 대신 interface 키워드 활용
메소드의 정의만 해두고 구현체는 존재하지 않음
인터페이스 사용하기

class Car implements Vehicle {...}
class MotorCycle implements Vehicle {...}
class Airplane implements Vehicle {...}

void handleVehicle(Vehicle vehicle){...}

Vehicle car = new Car();
handleVehicle(car);

Vehicle motorCycle = new MotorCycle();
handleVehilce(motorCycle);
-인터페이스를 파라미터로 받을 수 있음

인터페이스를 사용하는 이유
다양한 탈 것을 정의하는 과정

현재 존재하는 탈 것에는 자동차, 모토사이클, 비행기가 존재함
자동차는 핸들을 좌우로 움직이면서 운전함
모토사이클은 말을 통해 운전함
비행기는 오토파일럿 기능을 활용하여 운전함
클래스로 구현해본다면

class Car{
  void drive(){// 핸들 운전}
}

class Carriage {
  void drive(){//말이 운전}
}
class Airplane{
  void drive(){//오토파일럿 운전}
}
profile
